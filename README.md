# goit-algo2-hw-08

**Завдання 1. Оптимізація доступу до даних за допомогою LRU-кешу**\
Реалізуйте програму, що демонструє, як LRU-кеш пришвидшує багаторазові «гарячі» запити до великого масиву чисел.

_Результати виконання:_\
Тест 1. Результати тестування продуктивності:\
Без кешу : 6.91 c\
LRU-кеш  : 3.02 c  (прискорення ×2.3)

Тест 2. Результати тестування продуктивності:\
Без кешу : 6.28 c\
LRU-кеш  : 2.97 c  (прискорення ×2.1)

Тест 3. Результати тестування продуктивності:\
Без кешу : 8.14 c\
LRU-кеш  : 3.25 c  (прискорення ×2.5)

**Висновок: алгоритм з LRU-кешем працює коректно та стабільно прискорює обробку повторюваних запитів до масиву даних. Результати трьох тестів показують зменшення часу виконання приблизно у 2-2,5 раза порівняно з виконанням без кешу, що підтверджує ефективність кешування «гарячих» діапазонів. Незначні коливання часу між тестами пояснюються випадковим характером запитів, але загальна тенденція прискорення з використанням LRU-кешу зберігається в усіх випадках.**\
\
\
\
\
**Завдання 2. Реалізація Rate Limiter з використанням алгоритму Sliding Window для обмеження частоти повідомлень у чаті**\
У чат-системі необхідно реалізувати механізм обмеження частоти повідомлень від користувачів для запобігання спаму. Реалізація повинна використовувати алгоритм Sliding Window для точного контролю часових інтервалів, який дозволяє відстежувати кількість повідомлень у заданому часовому вікні й обмежувати користувачів у надсиланні повідомлень, якщо ліміт перевищено.

_Результати виконання:_\
=== Симуляція потоку повідомлень ===\
Повідомлення  1 | Користувач 2 | ✓\
Повідомлення  2 | Користувач 3 | ✓\
Повідомлення  3 | Користувач 4 | ✓\
Повідомлення  4 | Користувач 5 | ✓\
Повідомлення  5 | Користувач 1 | ✓\
Повідомлення  6 | Користувач 2 | × (очікування 6.7с)\
Повідомлення  7 | Користувач 3 | × (очікування 6.6с)\
Повідомлення  8 | Користувач 4 | × (очікування 6.6с)\
Повідомлення  9 | Користувач 5 | × (очікування 6.9с)\
Повідомлення 10 | Користувач 1 | × (очікування 7.2с)

Очікуємо 4 секунди...

=== Нова серія повідомлень після очікування ===\
Повідомлення 11 | Користувач 2 | ✓\
Повідомлення 12 | Користувач 3 | × (очікування 0.1с)\
Повідомлення 13 | Користувач 4 | × (очікування 0.0с)\
Повідомлення 14 | Користувач 5 | ✓\
Повідомлення 15 | Користувач 1 | × (очікування 0.2с)\
Повідомлення 16 | Користувач 2 | × (очікування 7.4с)\
Повідомлення 17 | Користувач 3 | ✓\
Повідомлення 18 | Користувач 4 | ✓\
Повідомлення 19 | Користувач 5 | × (очікування 8.0с)\
Повідомлення 20 | Користувач 1 | ✓


**Висновок: алгоритм працює коректно, обмежує надсилання повідомлень у межах 10-секундного вікна. Перші повідомлення від користувачів завжди дозволені (✓), повторні надсилання в межах вікна блокуються (×) з правильним розрахунком часу очікування до наступного дозволеного повідомлення. Після очікування блоковані користувачі знову можуть надсилати повідомлення, а повідомлення, що вийшли за межі вікна, видаляються, що демонструє коректну роботу механізму Sliding Window.**
